/*
 * Precisely APIs
 * Enhance & enrich your data, applications, business processes, and workflows with rich location, information, and identify APIs.
 *
 * The version of the OpenAPI document: 17.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.precisely.apis;

import com.precisely.ApiCallback;
import com.precisely.ApiClient;
import com.precisely.ApiException;
import com.precisely.ApiResponse;
import com.precisely.Configuration;
import com.precisely.Pair;
import com.precisely.ProgressRequestBody;
import com.precisely.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.precisely.apis.model.BasicBoundary;
import com.precisely.apis.model.ErrorInfo;
import com.precisely.apis.model.POIBoundaryAddressRequest;
import com.precisely.apis.model.POIBoundaryLocationRequest;
import com.precisely.apis.model.POIBoundaryResponse;
import com.precisely.apis.model.PoiBoundary;
import com.precisely.apis.model.TravelBoundaries;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ZonesServiceApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ZonesServiceApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ZonesServiceApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getBasicBoundaryByAddress
     * @param address Address around which Basic Boundary is requested (required)
     * @param country Three digit ISO country code (optional)
     * @param distance  (optional)
     * @param distanceUnit  (optional)
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4. (optional)
     * @param responseSrs  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getBasicBoundaryByAddressCall(String address, String country, String distance, String distanceUnit, String resolution, String responseSrs, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/zones/v1/basicboundary/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (country != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("country", country));
        }

        if (distance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distance", distance));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        if (resolution != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("resolution", resolution));
        }

        if (responseSrs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("responseSrs", responseSrs));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getBasicBoundaryByAddressValidateBeforeCall(String address, String country, String distance, String distanceUnit, String resolution, String responseSrs, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getBasicBoundaryByAddress(Async)");
        }
        

        okhttp3.Call localVarCall = getBasicBoundaryByAddressCall(address, country, distance, distanceUnit, resolution, responseSrs, _callback);
        return localVarCall;

    }

    /**
     * Gets Basic Boundary by Address.
     * Gets Basic Boundary by Address.
     * @param address Address around which Basic Boundary is requested (required)
     * @param country Three digit ISO country code (optional)
     * @param distance  (optional)
     * @param distanceUnit  (optional)
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4. (optional)
     * @param responseSrs  (optional)
     * @return BasicBoundary
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public BasicBoundary getBasicBoundaryByAddress(String address, String country, String distance, String distanceUnit, String resolution, String responseSrs) throws ApiException {
        ApiResponse<BasicBoundary> localVarResp = getBasicBoundaryByAddressWithHttpInfo(address, country, distance, distanceUnit, resolution, responseSrs);
        return localVarResp.getData();
    }

    /**
     * Gets Basic Boundary by Address.
     * Gets Basic Boundary by Address.
     * @param address Address around which Basic Boundary is requested (required)
     * @param country Three digit ISO country code (optional)
     * @param distance  (optional)
     * @param distanceUnit  (optional)
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4. (optional)
     * @param responseSrs  (optional)
     * @return ApiResponse&lt;BasicBoundary&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BasicBoundary> getBasicBoundaryByAddressWithHttpInfo(String address, String country, String distance, String distanceUnit, String resolution, String responseSrs) throws ApiException {
        okhttp3.Call localVarCall = getBasicBoundaryByAddressValidateBeforeCall(address, country, distance, distanceUnit, resolution, responseSrs, null);
        Type localVarReturnType = new TypeToken<BasicBoundary>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets Basic Boundary by Address. (asynchronously)
     * Gets Basic Boundary by Address.
     * @param address Address around which Basic Boundary is requested (required)
     * @param country Three digit ISO country code (optional)
     * @param distance  (optional)
     * @param distanceUnit  (optional)
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4. (optional)
     * @param responseSrs  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getBasicBoundaryByAddressAsync(String address, String country, String distance, String distanceUnit, String resolution, String responseSrs, final ApiCallback<BasicBoundary> _callback) throws ApiException {

        okhttp3.Call localVarCall = getBasicBoundaryByAddressValidateBeforeCall(address, country, distance, distanceUnit, resolution, responseSrs, _callback);
        Type localVarReturnType = new TypeToken<BasicBoundary>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getBasicBoundaryByLocation
     * @param latitude Latitude around which Basic Boundary is requested (required)
     * @param longitude Longitude around which Basic Boundary is requested (required)
     * @param distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number. (required)
     * @param distanceUnit  (optional)
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4. (optional)
     * @param responseSrs  (optional)
     * @param srsName  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getBasicBoundaryByLocationCall(String latitude, String longitude, String distance, String distanceUnit, String resolution, String responseSrs, String srsName, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/zones/v1/basicboundary/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (distance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distance", distance));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        if (resolution != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("resolution", resolution));
        }

        if (responseSrs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("responseSrs", responseSrs));
        }

        if (srsName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("srsName", srsName));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getBasicBoundaryByLocationValidateBeforeCall(String latitude, String longitude, String distance, String distanceUnit, String resolution, String responseSrs, String srsName, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getBasicBoundaryByLocation(Async)");
        }
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getBasicBoundaryByLocation(Async)");
        }
        
        // verify the required parameter 'distance' is set
        if (distance == null) {
            throw new ApiException("Missing the required parameter 'distance' when calling getBasicBoundaryByLocation(Async)");
        }
        

        okhttp3.Call localVarCall = getBasicBoundaryByLocationCall(latitude, longitude, distance, distanceUnit, resolution, responseSrs, srsName, _callback);
        return localVarCall;

    }

    /**
     * Gets Basic Boundary by Location.
     * Gets Basic Boundary by Location.
     * @param latitude Latitude around which Basic Boundary is requested (required)
     * @param longitude Longitude around which Basic Boundary is requested (required)
     * @param distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number. (required)
     * @param distanceUnit  (optional)
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4. (optional)
     * @param responseSrs  (optional)
     * @param srsName  (optional)
     * @return BasicBoundary
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public BasicBoundary getBasicBoundaryByLocation(String latitude, String longitude, String distance, String distanceUnit, String resolution, String responseSrs, String srsName) throws ApiException {
        ApiResponse<BasicBoundary> localVarResp = getBasicBoundaryByLocationWithHttpInfo(latitude, longitude, distance, distanceUnit, resolution, responseSrs, srsName);
        return localVarResp.getData();
    }

    /**
     * Gets Basic Boundary by Location.
     * Gets Basic Boundary by Location.
     * @param latitude Latitude around which Basic Boundary is requested (required)
     * @param longitude Longitude around which Basic Boundary is requested (required)
     * @param distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number. (required)
     * @param distanceUnit  (optional)
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4. (optional)
     * @param responseSrs  (optional)
     * @param srsName  (optional)
     * @return ApiResponse&lt;BasicBoundary&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BasicBoundary> getBasicBoundaryByLocationWithHttpInfo(String latitude, String longitude, String distance, String distanceUnit, String resolution, String responseSrs, String srsName) throws ApiException {
        okhttp3.Call localVarCall = getBasicBoundaryByLocationValidateBeforeCall(latitude, longitude, distance, distanceUnit, resolution, responseSrs, srsName, null);
        Type localVarReturnType = new TypeToken<BasicBoundary>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets Basic Boundary by Location. (asynchronously)
     * Gets Basic Boundary by Location.
     * @param latitude Latitude around which Basic Boundary is requested (required)
     * @param longitude Longitude around which Basic Boundary is requested (required)
     * @param distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number. (required)
     * @param distanceUnit  (optional)
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4. (optional)
     * @param responseSrs  (optional)
     * @param srsName  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getBasicBoundaryByLocationAsync(String latitude, String longitude, String distance, String distanceUnit, String resolution, String responseSrs, String srsName, final ApiCallback<BasicBoundary> _callback) throws ApiException {

        okhttp3.Call localVarCall = getBasicBoundaryByLocationValidateBeforeCall(latitude, longitude, distance, distanceUnit, resolution, responseSrs, srsName, _callback);
        Type localVarReturnType = new TypeToken<BasicBoundary>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPOIBoundaryByAddress
     * @param address Address around which POI Boundary is requested (required)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. (optional)
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPOIBoundaryByAddressCall(String address, String categoryCode, String sicCode, String naicsCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/zones/v1/poiboundary/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (categoryCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("categoryCode", categoryCode));
        }

        if (sicCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sicCode", sicCode));
        }

        if (naicsCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("naicsCode", naicsCode));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPOIBoundaryByAddressValidateBeforeCall(String address, String categoryCode, String sicCode, String naicsCode, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getPOIBoundaryByAddress(Async)");
        }
        

        okhttp3.Call localVarCall = getPOIBoundaryByAddressCall(address, categoryCode, sicCode, naicsCode, _callback);
        return localVarCall;

    }

    /**
     * Gets Point of Interests Boundary by Address.
     * Gets Point of Interests Boundary by Address.
     * @param address Address around which POI Boundary is requested (required)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. (optional)
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed. (optional)
     * @return PoiBoundary
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public PoiBoundary getPOIBoundaryByAddress(String address, String categoryCode, String sicCode, String naicsCode) throws ApiException {
        ApiResponse<PoiBoundary> localVarResp = getPOIBoundaryByAddressWithHttpInfo(address, categoryCode, sicCode, naicsCode);
        return localVarResp.getData();
    }

    /**
     * Gets Point of Interests Boundary by Address.
     * Gets Point of Interests Boundary by Address.
     * @param address Address around which POI Boundary is requested (required)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. (optional)
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed. (optional)
     * @return ApiResponse&lt;PoiBoundary&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PoiBoundary> getPOIBoundaryByAddressWithHttpInfo(String address, String categoryCode, String sicCode, String naicsCode) throws ApiException {
        okhttp3.Call localVarCall = getPOIBoundaryByAddressValidateBeforeCall(address, categoryCode, sicCode, naicsCode, null);
        Type localVarReturnType = new TypeToken<PoiBoundary>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets Point of Interests Boundary by Address. (asynchronously)
     * Gets Point of Interests Boundary by Address.
     * @param address Address around which POI Boundary is requested (required)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. (optional)
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPOIBoundaryByAddressAsync(String address, String categoryCode, String sicCode, String naicsCode, final ApiCallback<PoiBoundary> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPOIBoundaryByAddressValidateBeforeCall(address, categoryCode, sicCode, naicsCode, _callback);
        Type localVarReturnType = new TypeToken<PoiBoundary>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPOIBoundaryByAddressBatch
     * @param poIBoundaryAddressRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPOIBoundaryByAddressBatchCall(POIBoundaryAddressRequest poIBoundaryAddressRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = poIBoundaryAddressRequest;

        // create path and map variables
        String localVarPath = "/zones/v1/poiboundary/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPOIBoundaryByAddressBatchValidateBeforeCall(POIBoundaryAddressRequest poIBoundaryAddressRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'poIBoundaryAddressRequest' is set
        if (poIBoundaryAddressRequest == null) {
            throw new ApiException("Missing the required parameter 'poIBoundaryAddressRequest' when calling getPOIBoundaryByAddressBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getPOIBoundaryByAddressBatchCall(poIBoundaryAddressRequest, _callback);
        return localVarCall;

    }

    /**
     * Batch method for getting Point of Interests Boundary by Address.
     * Batch method for getting Point of Interests Boundary by Address.
     * @param poIBoundaryAddressRequest  (required)
     * @return POIBoundaryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public POIBoundaryResponse getPOIBoundaryByAddressBatch(POIBoundaryAddressRequest poIBoundaryAddressRequest) throws ApiException {
        ApiResponse<POIBoundaryResponse> localVarResp = getPOIBoundaryByAddressBatchWithHttpInfo(poIBoundaryAddressRequest);
        return localVarResp.getData();
    }

    /**
     * Batch method for getting Point of Interests Boundary by Address.
     * Batch method for getting Point of Interests Boundary by Address.
     * @param poIBoundaryAddressRequest  (required)
     * @return ApiResponse&lt;POIBoundaryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<POIBoundaryResponse> getPOIBoundaryByAddressBatchWithHttpInfo(POIBoundaryAddressRequest poIBoundaryAddressRequest) throws ApiException {
        okhttp3.Call localVarCall = getPOIBoundaryByAddressBatchValidateBeforeCall(poIBoundaryAddressRequest, null);
        Type localVarReturnType = new TypeToken<POIBoundaryResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Batch method for getting Point of Interests Boundary by Address. (asynchronously)
     * Batch method for getting Point of Interests Boundary by Address.
     * @param poIBoundaryAddressRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPOIBoundaryByAddressBatchAsync(POIBoundaryAddressRequest poIBoundaryAddressRequest, final ApiCallback<POIBoundaryResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPOIBoundaryByAddressBatchValidateBeforeCall(poIBoundaryAddressRequest, _callback);
        Type localVarReturnType = new TypeToken<POIBoundaryResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPOIBoundaryByLocation
     * @param latitude Latitude around which POI Boundary is requested (required)
     * @param longitude Longitude around which POI Boundary is requested (required)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes (optional)
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPOIBoundaryByLocationCall(String latitude, String longitude, String categoryCode, String sicCode, String naicsCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/zones/v1/poiboundary/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (categoryCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("categoryCode", categoryCode));
        }

        if (sicCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sicCode", sicCode));
        }

        if (naicsCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("naicsCode", naicsCode));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPOIBoundaryByLocationValidateBeforeCall(String latitude, String longitude, String categoryCode, String sicCode, String naicsCode, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getPOIBoundaryByLocation(Async)");
        }
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getPOIBoundaryByLocation(Async)");
        }
        

        okhttp3.Call localVarCall = getPOIBoundaryByLocationCall(latitude, longitude, categoryCode, sicCode, naicsCode, _callback);
        return localVarCall;

    }

    /**
     * Get Point of Interests Boundary by Location.
     * Get Point of Interests Boundary by Location.
     * @param latitude Latitude around which POI Boundary is requested (required)
     * @param longitude Longitude around which POI Boundary is requested (required)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes (optional)
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed. (optional)
     * @return PoiBoundary
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public PoiBoundary getPOIBoundaryByLocation(String latitude, String longitude, String categoryCode, String sicCode, String naicsCode) throws ApiException {
        ApiResponse<PoiBoundary> localVarResp = getPOIBoundaryByLocationWithHttpInfo(latitude, longitude, categoryCode, sicCode, naicsCode);
        return localVarResp.getData();
    }

    /**
     * Get Point of Interests Boundary by Location.
     * Get Point of Interests Boundary by Location.
     * @param latitude Latitude around which POI Boundary is requested (required)
     * @param longitude Longitude around which POI Boundary is requested (required)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes (optional)
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed. (optional)
     * @return ApiResponse&lt;PoiBoundary&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PoiBoundary> getPOIBoundaryByLocationWithHttpInfo(String latitude, String longitude, String categoryCode, String sicCode, String naicsCode) throws ApiException {
        okhttp3.Call localVarCall = getPOIBoundaryByLocationValidateBeforeCall(latitude, longitude, categoryCode, sicCode, naicsCode, null);
        Type localVarReturnType = new TypeToken<PoiBoundary>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Point of Interests Boundary by Location. (asynchronously)
     * Get Point of Interests Boundary by Location.
     * @param latitude Latitude around which POI Boundary is requested (required)
     * @param longitude Longitude around which POI Boundary is requested (required)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes (optional)
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPOIBoundaryByLocationAsync(String latitude, String longitude, String categoryCode, String sicCode, String naicsCode, final ApiCallback<PoiBoundary> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPOIBoundaryByLocationValidateBeforeCall(latitude, longitude, categoryCode, sicCode, naicsCode, _callback);
        Type localVarReturnType = new TypeToken<PoiBoundary>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPOIBoundaryByLocationBatch
     * @param poIBoundaryLocationRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPOIBoundaryByLocationBatchCall(POIBoundaryLocationRequest poIBoundaryLocationRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = poIBoundaryLocationRequest;

        // create path and map variables
        String localVarPath = "/zones/v1/poiboundary/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPOIBoundaryByLocationBatchValidateBeforeCall(POIBoundaryLocationRequest poIBoundaryLocationRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'poIBoundaryLocationRequest' is set
        if (poIBoundaryLocationRequest == null) {
            throw new ApiException("Missing the required parameter 'poIBoundaryLocationRequest' when calling getPOIBoundaryByLocationBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getPOIBoundaryByLocationBatchCall(poIBoundaryLocationRequest, _callback);
        return localVarCall;

    }

    /**
     * Batch method for getting Point of Interests Boundary by Location.
     * Batch method for getting Point of Interests Boundary by Location.
     * @param poIBoundaryLocationRequest  (required)
     * @return POIBoundaryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public POIBoundaryResponse getPOIBoundaryByLocationBatch(POIBoundaryLocationRequest poIBoundaryLocationRequest) throws ApiException {
        ApiResponse<POIBoundaryResponse> localVarResp = getPOIBoundaryByLocationBatchWithHttpInfo(poIBoundaryLocationRequest);
        return localVarResp.getData();
    }

    /**
     * Batch method for getting Point of Interests Boundary by Location.
     * Batch method for getting Point of Interests Boundary by Location.
     * @param poIBoundaryLocationRequest  (required)
     * @return ApiResponse&lt;POIBoundaryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<POIBoundaryResponse> getPOIBoundaryByLocationBatchWithHttpInfo(POIBoundaryLocationRequest poIBoundaryLocationRequest) throws ApiException {
        okhttp3.Call localVarCall = getPOIBoundaryByLocationBatchValidateBeforeCall(poIBoundaryLocationRequest, null);
        Type localVarReturnType = new TypeToken<POIBoundaryResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Batch method for getting Point of Interests Boundary by Location. (asynchronously)
     * Batch method for getting Point of Interests Boundary by Location.
     * @param poIBoundaryLocationRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPOIBoundaryByLocationBatchAsync(POIBoundaryLocationRequest poIBoundaryLocationRequest, final ApiCallback<POIBoundaryResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPOIBoundaryByLocationBatchValidateBeforeCall(poIBoundaryLocationRequest, _callback);
        Type localVarReturnType = new TypeToken<POIBoundaryResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTravelBoundaryByDistance
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format (optional)
     * @param address Address around which Basic Boundary is requested. (optional)
     * @param costs Travel time used to calculate the travel boundary. (optional)
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional)
     * @param db Mode of commute. (optional)
     * @param country 3 character ISO code or country name. (optional)
     * @param maxOffroadDistance Maximum distance to allow travel off the road network. (optional)
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional)
     * @param destinationSrs Desired coordinate system of the travel boundary. (optional)
     * @param majorRoads Whether to include all roads in the calculation or just major roads. (optional, default to true)
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time (optional)
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time (optional)
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex (optional)
     * @param bandingStyle Style of banding to be used in the result (optional)
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds (optional)
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types). (optional)
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTravelBoundaryByDistanceCall(String point, String address, String costs, String costUnit, String db, String country, String maxOffroadDistance, String maxOffroadDistanceUnit, String destinationSrs, String majorRoads, String returnHoles, String returnIslands, String simplificationFactor, String bandingStyle, String historicTrafficTimeBucket, String defaultAmbientSpeed, String ambientSpeedUnit, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/zones/v1/travelboundary/bydistance";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (point != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("point", point));
        }

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (costs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("costs", costs));
        }

        if (costUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("costUnit", costUnit));
        }

        if (db != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("db", db));
        }

        if (country != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("country", country));
        }

        if (maxOffroadDistance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxOffroadDistance", maxOffroadDistance));
        }

        if (maxOffroadDistanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxOffroadDistanceUnit", maxOffroadDistanceUnit));
        }

        if (destinationSrs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("destinationSrs", destinationSrs));
        }

        if (majorRoads != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("majorRoads", majorRoads));
        }

        if (returnHoles != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnHoles", returnHoles));
        }

        if (returnIslands != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnIslands", returnIslands));
        }

        if (simplificationFactor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("simplificationFactor", simplificationFactor));
        }

        if (bandingStyle != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bandingStyle", bandingStyle));
        }

        if (historicTrafficTimeBucket != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("historicTrafficTimeBucket", historicTrafficTimeBucket));
        }

        if (defaultAmbientSpeed != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("defaultAmbientSpeed", defaultAmbientSpeed));
        }

        if (ambientSpeedUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ambientSpeedUnit", ambientSpeedUnit));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTravelBoundaryByDistanceValidateBeforeCall(String point, String address, String costs, String costUnit, String db, String country, String maxOffroadDistance, String maxOffroadDistanceUnit, String destinationSrs, String majorRoads, String returnHoles, String returnIslands, String simplificationFactor, String bandingStyle, String historicTrafficTimeBucket, String defaultAmbientSpeed, String ambientSpeedUnit, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getTravelBoundaryByDistanceCall(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, _callback);
        return localVarCall;

    }

    /**
     * Get TravelBoundary By Distance.
     * Returns the travel boundary based on travel distance.
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format (optional)
     * @param address Address around which Basic Boundary is requested. (optional)
     * @param costs Travel time used to calculate the travel boundary. (optional)
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional)
     * @param db Mode of commute. (optional)
     * @param country 3 character ISO code or country name. (optional)
     * @param maxOffroadDistance Maximum distance to allow travel off the road network. (optional)
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional)
     * @param destinationSrs Desired coordinate system of the travel boundary. (optional)
     * @param majorRoads Whether to include all roads in the calculation or just major roads. (optional, default to true)
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time (optional)
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time (optional)
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex (optional)
     * @param bandingStyle Style of banding to be used in the result (optional)
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds (optional)
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types). (optional)
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed. (optional)
     * @return TravelBoundaries
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public TravelBoundaries getTravelBoundaryByDistance(String point, String address, String costs, String costUnit, String db, String country, String maxOffroadDistance, String maxOffroadDistanceUnit, String destinationSrs, String majorRoads, String returnHoles, String returnIslands, String simplificationFactor, String bandingStyle, String historicTrafficTimeBucket, String defaultAmbientSpeed, String ambientSpeedUnit) throws ApiException {
        ApiResponse<TravelBoundaries> localVarResp = getTravelBoundaryByDistanceWithHttpInfo(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit);
        return localVarResp.getData();
    }

    /**
     * Get TravelBoundary By Distance.
     * Returns the travel boundary based on travel distance.
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format (optional)
     * @param address Address around which Basic Boundary is requested. (optional)
     * @param costs Travel time used to calculate the travel boundary. (optional)
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional)
     * @param db Mode of commute. (optional)
     * @param country 3 character ISO code or country name. (optional)
     * @param maxOffroadDistance Maximum distance to allow travel off the road network. (optional)
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional)
     * @param destinationSrs Desired coordinate system of the travel boundary. (optional)
     * @param majorRoads Whether to include all roads in the calculation or just major roads. (optional, default to true)
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time (optional)
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time (optional)
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex (optional)
     * @param bandingStyle Style of banding to be used in the result (optional)
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds (optional)
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types). (optional)
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed. (optional)
     * @return ApiResponse&lt;TravelBoundaries&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TravelBoundaries> getTravelBoundaryByDistanceWithHttpInfo(String point, String address, String costs, String costUnit, String db, String country, String maxOffroadDistance, String maxOffroadDistanceUnit, String destinationSrs, String majorRoads, String returnHoles, String returnIslands, String simplificationFactor, String bandingStyle, String historicTrafficTimeBucket, String defaultAmbientSpeed, String ambientSpeedUnit) throws ApiException {
        okhttp3.Call localVarCall = getTravelBoundaryByDistanceValidateBeforeCall(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, null);
        Type localVarReturnType = new TypeToken<TravelBoundaries>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get TravelBoundary By Distance. (asynchronously)
     * Returns the travel boundary based on travel distance.
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format (optional)
     * @param address Address around which Basic Boundary is requested. (optional)
     * @param costs Travel time used to calculate the travel boundary. (optional)
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional)
     * @param db Mode of commute. (optional)
     * @param country 3 character ISO code or country name. (optional)
     * @param maxOffroadDistance Maximum distance to allow travel off the road network. (optional)
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional)
     * @param destinationSrs Desired coordinate system of the travel boundary. (optional)
     * @param majorRoads Whether to include all roads in the calculation or just major roads. (optional, default to true)
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time (optional)
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time (optional)
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex (optional)
     * @param bandingStyle Style of banding to be used in the result (optional)
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds (optional)
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types). (optional)
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTravelBoundaryByDistanceAsync(String point, String address, String costs, String costUnit, String db, String country, String maxOffroadDistance, String maxOffroadDistanceUnit, String destinationSrs, String majorRoads, String returnHoles, String returnIslands, String simplificationFactor, String bandingStyle, String historicTrafficTimeBucket, String defaultAmbientSpeed, String ambientSpeedUnit, final ApiCallback<TravelBoundaries> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTravelBoundaryByDistanceValidateBeforeCall(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, _callback);
        Type localVarReturnType = new TypeToken<TravelBoundaries>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTravelBoundaryByTime
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format (optional)
     * @param address Starting address from where the travel boundary is calculated. (optional)
     * @param costs Travel time used to calculate the travel boundary. (optional)
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional)
     * @param db Mode of commute. (optional)
     * @param country 3 character ISO code or country name. (optional)
     * @param maxOffroadDistance Maximum distance to allow travel off the road network. (optional)
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional)
     * @param destinationSrs Desired coordinate system of the travel boundary. (optional)
     * @param majorRoads Whether to include all roads in the calculation or just major roads. (optional, default to true)
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time (optional)
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time (optional)
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex (optional)
     * @param bandingStyle Style of banding to be used in the result (optional)
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds (optional)
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types). (optional)
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTravelBoundaryByTimeCall(String point, String address, String costs, String costUnit, String db, String country, String maxOffroadDistance, String maxOffroadDistanceUnit, String destinationSrs, String majorRoads, String returnHoles, String returnIslands, String simplificationFactor, String bandingStyle, String historicTrafficTimeBucket, String defaultAmbientSpeed, String ambientSpeedUnit, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/zones/v1/travelboundary/bytime";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (point != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("point", point));
        }

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (costs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("costs", costs));
        }

        if (costUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("costUnit", costUnit));
        }

        if (db != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("db", db));
        }

        if (country != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("country", country));
        }

        if (maxOffroadDistance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxOffroadDistance", maxOffroadDistance));
        }

        if (maxOffroadDistanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxOffroadDistanceUnit", maxOffroadDistanceUnit));
        }

        if (destinationSrs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("destinationSrs", destinationSrs));
        }

        if (majorRoads != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("majorRoads", majorRoads));
        }

        if (returnHoles != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnHoles", returnHoles));
        }

        if (returnIslands != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnIslands", returnIslands));
        }

        if (simplificationFactor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("simplificationFactor", simplificationFactor));
        }

        if (bandingStyle != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bandingStyle", bandingStyle));
        }

        if (historicTrafficTimeBucket != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("historicTrafficTimeBucket", historicTrafficTimeBucket));
        }

        if (defaultAmbientSpeed != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("defaultAmbientSpeed", defaultAmbientSpeed));
        }

        if (ambientSpeedUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ambientSpeedUnit", ambientSpeedUnit));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTravelBoundaryByTimeValidateBeforeCall(String point, String address, String costs, String costUnit, String db, String country, String maxOffroadDistance, String maxOffroadDistanceUnit, String destinationSrs, String majorRoads, String returnHoles, String returnIslands, String simplificationFactor, String bandingStyle, String historicTrafficTimeBucket, String defaultAmbientSpeed, String ambientSpeedUnit, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getTravelBoundaryByTimeCall(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, _callback);
        return localVarCall;

    }

    /**
     * Get TravelBoundary By Time.
     * Travel boundary based on travel time.
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format (optional)
     * @param address Starting address from where the travel boundary is calculated. (optional)
     * @param costs Travel time used to calculate the travel boundary. (optional)
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional)
     * @param db Mode of commute. (optional)
     * @param country 3 character ISO code or country name. (optional)
     * @param maxOffroadDistance Maximum distance to allow travel off the road network. (optional)
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional)
     * @param destinationSrs Desired coordinate system of the travel boundary. (optional)
     * @param majorRoads Whether to include all roads in the calculation or just major roads. (optional, default to true)
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time (optional)
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time (optional)
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex (optional)
     * @param bandingStyle Style of banding to be used in the result (optional)
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds (optional)
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types). (optional)
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed. (optional)
     * @return TravelBoundaries
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public TravelBoundaries getTravelBoundaryByTime(String point, String address, String costs, String costUnit, String db, String country, String maxOffroadDistance, String maxOffroadDistanceUnit, String destinationSrs, String majorRoads, String returnHoles, String returnIslands, String simplificationFactor, String bandingStyle, String historicTrafficTimeBucket, String defaultAmbientSpeed, String ambientSpeedUnit) throws ApiException {
        ApiResponse<TravelBoundaries> localVarResp = getTravelBoundaryByTimeWithHttpInfo(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit);
        return localVarResp.getData();
    }

    /**
     * Get TravelBoundary By Time.
     * Travel boundary based on travel time.
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format (optional)
     * @param address Starting address from where the travel boundary is calculated. (optional)
     * @param costs Travel time used to calculate the travel boundary. (optional)
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional)
     * @param db Mode of commute. (optional)
     * @param country 3 character ISO code or country name. (optional)
     * @param maxOffroadDistance Maximum distance to allow travel off the road network. (optional)
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional)
     * @param destinationSrs Desired coordinate system of the travel boundary. (optional)
     * @param majorRoads Whether to include all roads in the calculation or just major roads. (optional, default to true)
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time (optional)
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time (optional)
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex (optional)
     * @param bandingStyle Style of banding to be used in the result (optional)
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds (optional)
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types). (optional)
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed. (optional)
     * @return ApiResponse&lt;TravelBoundaries&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TravelBoundaries> getTravelBoundaryByTimeWithHttpInfo(String point, String address, String costs, String costUnit, String db, String country, String maxOffroadDistance, String maxOffroadDistanceUnit, String destinationSrs, String majorRoads, String returnHoles, String returnIslands, String simplificationFactor, String bandingStyle, String historicTrafficTimeBucket, String defaultAmbientSpeed, String ambientSpeedUnit) throws ApiException {
        okhttp3.Call localVarCall = getTravelBoundaryByTimeValidateBeforeCall(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, null);
        Type localVarReturnType = new TypeToken<TravelBoundaries>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get TravelBoundary By Time. (asynchronously)
     * Travel boundary based on travel time.
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format (optional)
     * @param address Starting address from where the travel boundary is calculated. (optional)
     * @param costs Travel time used to calculate the travel boundary. (optional)
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional)
     * @param db Mode of commute. (optional)
     * @param country 3 character ISO code or country name. (optional)
     * @param maxOffroadDistance Maximum distance to allow travel off the road network. (optional)
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional)
     * @param destinationSrs Desired coordinate system of the travel boundary. (optional)
     * @param majorRoads Whether to include all roads in the calculation or just major roads. (optional, default to true)
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time (optional)
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time (optional)
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex (optional)
     * @param bandingStyle Style of banding to be used in the result (optional)
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds (optional)
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types). (optional)
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTravelBoundaryByTimeAsync(String point, String address, String costs, String costUnit, String db, String country, String maxOffroadDistance, String maxOffroadDistanceUnit, String destinationSrs, String majorRoads, String returnHoles, String returnIslands, String simplificationFactor, String bandingStyle, String historicTrafficTimeBucket, String defaultAmbientSpeed, String ambientSpeedUnit, final ApiCallback<TravelBoundaries> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTravelBoundaryByTimeValidateBeforeCall(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, _callback);
        Type localVarReturnType = new TypeToken<TravelBoundaries>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
