/*
 * Precisely APIs
 * Enhance & enrich your data, applications, business processes, and workflows with rich location, information, and identify APIs.
 *
 * The version of the OpenAPI document: 11.9.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.precisely.apis;

import com.precisely.ApiCallback;
import com.precisely.ApiClient;
import com.precisely.ApiException;
import com.precisely.ApiResponse;
import com.precisely.Configuration;
import com.precisely.Pair;
import com.precisely.ProgressRequestBody;
import com.precisely.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.precisely.apis.model.CrimeRiskByAddressBatchRequest;
import com.precisely.apis.model.CrimeRiskByLocationBatchRequest;
import com.precisely.apis.model.CrimeRiskResponse;
import com.precisely.apis.model.CrimeRiskResponseList;
import com.precisely.apis.model.DistanceToFloodHazardAddressRequest;
import com.precisely.apis.model.DistanceToFloodHazardLocationRequest;
import com.precisely.apis.model.DistanceToFloodHazardResponse;
import com.precisely.apis.model.EarthquakeHistory;
import com.precisely.apis.model.EarthquakeRiskByAddressRequest;
import com.precisely.apis.model.EarthquakeRiskByLocationRequest;
import com.precisely.apis.model.EarthquakeRiskResponse;
import com.precisely.apis.model.EarthquakeRiskResponseList;
import com.precisely.apis.model.ErrorInfo;
import com.precisely.apis.model.FireHistory;
import com.precisely.apis.model.FireRiskByAddressRequest;
import com.precisely.apis.model.FireRiskByLocationRequest;
import com.precisely.apis.model.FireRiskResponse;
import com.precisely.apis.model.FireRiskResponseList;
import com.precisely.apis.model.FireStations;
import com.precisely.apis.model.FloodRiskByAddressRequest;
import com.precisely.apis.model.FloodRiskByLocationRequest;
import com.precisely.apis.model.FloodRiskResponse;
import com.precisely.apis.model.FloodRiskResponseList;
import com.precisely.apis.model.WaterBodyResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RisksServiceApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public RisksServiceApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RisksServiceApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getCrimeRiskByAddress
     * @param address free form address text (required)
     * @param type this is crime type; valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCrimeRiskByAddressCall(String address, String type, String includeGeometry, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/crime/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (includeGeometry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeGeometry", includeGeometry));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCrimeRiskByAddressValidateBeforeCall(String address, String type, String includeGeometry, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getCrimeRiskByAddress(Async)");
        }
        

        okhttp3.Call localVarCall = getCrimeRiskByAddressCall(address, type, includeGeometry, _callback);
        return localVarCall;

    }

    /**
     * Get Crime Risk By Address
     * Accepts addresses as input and Returns local crime indexes.
     * @param address free form address text (required)
     * @param type this is crime type; valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return CrimeRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public CrimeRiskResponse getCrimeRiskByAddress(String address, String type, String includeGeometry) throws ApiException {
        ApiResponse<CrimeRiskResponse> localVarResp = getCrimeRiskByAddressWithHttpInfo(address, type, includeGeometry);
        return localVarResp.getData();
    }

    /**
     * Get Crime Risk By Address
     * Accepts addresses as input and Returns local crime indexes.
     * @param address free form address text (required)
     * @param type this is crime type; valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;CrimeRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CrimeRiskResponse> getCrimeRiskByAddressWithHttpInfo(String address, String type, String includeGeometry) throws ApiException {
        okhttp3.Call localVarCall = getCrimeRiskByAddressValidateBeforeCall(address, type, includeGeometry, null);
        Type localVarReturnType = new TypeToken<CrimeRiskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Crime Risk By Address (asynchronously)
     * Accepts addresses as input and Returns local crime indexes.
     * @param address free form address text (required)
     * @param type this is crime type; valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCrimeRiskByAddressAsync(String address, String type, String includeGeometry, final ApiCallback<CrimeRiskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCrimeRiskByAddressValidateBeforeCall(address, type, includeGeometry, _callback);
        Type localVarReturnType = new TypeToken<CrimeRiskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCrimeRiskByAddressBatch
     * @param crimeRiskByAddressBatchRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCrimeRiskByAddressBatchCall(CrimeRiskByAddressBatchRequest crimeRiskByAddressBatchRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = crimeRiskByAddressBatchRequest;

        // create path and map variables
        String localVarPath = "/risks/v1/crime/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCrimeRiskByAddressBatchValidateBeforeCall(CrimeRiskByAddressBatchRequest crimeRiskByAddressBatchRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'crimeRiskByAddressBatchRequest' is set
        if (crimeRiskByAddressBatchRequest == null) {
            throw new ApiException("Missing the required parameter 'crimeRiskByAddressBatchRequest' when calling getCrimeRiskByAddressBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getCrimeRiskByAddressBatchCall(crimeRiskByAddressBatchRequest, _callback);
        return localVarCall;

    }

    /**
     * Post Crime Risk By Address
     * This is a Batch offering for &#39;Crime Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve local crime indexes.
     * @param crimeRiskByAddressBatchRequest  (required)
     * @return CrimeRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public CrimeRiskResponseList getCrimeRiskByAddressBatch(CrimeRiskByAddressBatchRequest crimeRiskByAddressBatchRequest) throws ApiException {
        ApiResponse<CrimeRiskResponseList> localVarResp = getCrimeRiskByAddressBatchWithHttpInfo(crimeRiskByAddressBatchRequest);
        return localVarResp.getData();
    }

    /**
     * Post Crime Risk By Address
     * This is a Batch offering for &#39;Crime Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve local crime indexes.
     * @param crimeRiskByAddressBatchRequest  (required)
     * @return ApiResponse&lt;CrimeRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CrimeRiskResponseList> getCrimeRiskByAddressBatchWithHttpInfo(CrimeRiskByAddressBatchRequest crimeRiskByAddressBatchRequest) throws ApiException {
        okhttp3.Call localVarCall = getCrimeRiskByAddressBatchValidateBeforeCall(crimeRiskByAddressBatchRequest, null);
        Type localVarReturnType = new TypeToken<CrimeRiskResponseList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post Crime Risk By Address (asynchronously)
     * This is a Batch offering for &#39;Crime Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve local crime indexes.
     * @param crimeRiskByAddressBatchRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCrimeRiskByAddressBatchAsync(CrimeRiskByAddressBatchRequest crimeRiskByAddressBatchRequest, final ApiCallback<CrimeRiskResponseList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCrimeRiskByAddressBatchValidateBeforeCall(crimeRiskByAddressBatchRequest, _callback);
        Type localVarReturnType = new TypeToken<CrimeRiskResponseList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCrimeRiskByLocation
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param type this is crime type; valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCrimeRiskByLocationCall(String longitude, String latitude, String type, String includeGeometry, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/crime/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (includeGeometry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeGeometry", includeGeometry));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCrimeRiskByLocationValidateBeforeCall(String longitude, String latitude, String type, String includeGeometry, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getCrimeRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getCrimeRiskByLocation(Async)");
        }
        

        okhttp3.Call localVarCall = getCrimeRiskByLocationCall(longitude, latitude, type, includeGeometry, _callback);
        return localVarCall;

    }

    /**
     * Get Crime Risk By  Location
     * Accepts latitude/longitude as input and returns and Returns local crime indexes.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param type this is crime type; valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return CrimeRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public CrimeRiskResponse getCrimeRiskByLocation(String longitude, String latitude, String type, String includeGeometry) throws ApiException {
        ApiResponse<CrimeRiskResponse> localVarResp = getCrimeRiskByLocationWithHttpInfo(longitude, latitude, type, includeGeometry);
        return localVarResp.getData();
    }

    /**
     * Get Crime Risk By  Location
     * Accepts latitude/longitude as input and returns and Returns local crime indexes.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param type this is crime type; valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;CrimeRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CrimeRiskResponse> getCrimeRiskByLocationWithHttpInfo(String longitude, String latitude, String type, String includeGeometry) throws ApiException {
        okhttp3.Call localVarCall = getCrimeRiskByLocationValidateBeforeCall(longitude, latitude, type, includeGeometry, null);
        Type localVarReturnType = new TypeToken<CrimeRiskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Crime Risk By  Location (asynchronously)
     * Accepts latitude/longitude as input and returns and Returns local crime indexes.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param type this is crime type; valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCrimeRiskByLocationAsync(String longitude, String latitude, String type, String includeGeometry, final ApiCallback<CrimeRiskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCrimeRiskByLocationValidateBeforeCall(longitude, latitude, type, includeGeometry, _callback);
        Type localVarReturnType = new TypeToken<CrimeRiskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCrimeRiskByLocationBatch
     * @param crimeRiskByLocationBatchRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCrimeRiskByLocationBatchCall(CrimeRiskByLocationBatchRequest crimeRiskByLocationBatchRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = crimeRiskByLocationBatchRequest;

        // create path and map variables
        String localVarPath = "/risks/v1/crime/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCrimeRiskByLocationBatchValidateBeforeCall(CrimeRiskByLocationBatchRequest crimeRiskByLocationBatchRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'crimeRiskByLocationBatchRequest' is set
        if (crimeRiskByLocationBatchRequest == null) {
            throw new ApiException("Missing the required parameter 'crimeRiskByLocationBatchRequest' when calling getCrimeRiskByLocationBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getCrimeRiskByLocationBatchCall(crimeRiskByLocationBatchRequest, _callback);
        return localVarCall;

    }

    /**
     * Post Crime Risk By Location
     * This is a Batch offering for &#39;Crime Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
     * @param crimeRiskByLocationBatchRequest  (required)
     * @return CrimeRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public CrimeRiskResponseList getCrimeRiskByLocationBatch(CrimeRiskByLocationBatchRequest crimeRiskByLocationBatchRequest) throws ApiException {
        ApiResponse<CrimeRiskResponseList> localVarResp = getCrimeRiskByLocationBatchWithHttpInfo(crimeRiskByLocationBatchRequest);
        return localVarResp.getData();
    }

    /**
     * Post Crime Risk By Location
     * This is a Batch offering for &#39;Crime Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
     * @param crimeRiskByLocationBatchRequest  (required)
     * @return ApiResponse&lt;CrimeRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CrimeRiskResponseList> getCrimeRiskByLocationBatchWithHttpInfo(CrimeRiskByLocationBatchRequest crimeRiskByLocationBatchRequest) throws ApiException {
        okhttp3.Call localVarCall = getCrimeRiskByLocationBatchValidateBeforeCall(crimeRiskByLocationBatchRequest, null);
        Type localVarReturnType = new TypeToken<CrimeRiskResponseList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post Crime Risk By Location (asynchronously)
     * This is a Batch offering for &#39;Crime Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
     * @param crimeRiskByLocationBatchRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCrimeRiskByLocationBatchAsync(CrimeRiskByLocationBatchRequest crimeRiskByLocationBatchRequest, final ApiCallback<CrimeRiskResponseList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCrimeRiskByLocationBatchValidateBeforeCall(crimeRiskByLocationBatchRequest, _callback);
        Type localVarReturnType = new TypeToken<CrimeRiskResponseList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getDistanceToCoastByAddress
     * @param address The address of the location (optional)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType This specifies the value of waterBodyType (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDistanceToCoastByAddressCall(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/shoreline/distancetofloodhazard/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (maxCandidates != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxCandidates", maxCandidates));
        }

        if (waterBodyType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("waterBodyType", waterBodyType));
        }

        if (searchDistance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("searchDistance", searchDistance));
        }

        if (searchDistanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("searchDistanceUnit", searchDistanceUnit));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDistanceToCoastByAddressValidateBeforeCall(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getDistanceToCoastByAddressCall(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, _callback);
        return localVarCall;

    }

    /**
     * Get Distance To Flood Hazard By Address
     * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
     * @param address The address of the location (optional)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType This specifies the value of waterBodyType (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return WaterBodyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public WaterBodyResponse getDistanceToCoastByAddress(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        ApiResponse<WaterBodyResponse> localVarResp = getDistanceToCoastByAddressWithHttpInfo(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit);
        return localVarResp.getData();
    }

    /**
     * Get Distance To Flood Hazard By Address
     * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
     * @param address The address of the location (optional)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType This specifies the value of waterBodyType (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return ApiResponse&lt;WaterBodyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WaterBodyResponse> getDistanceToCoastByAddressWithHttpInfo(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        okhttp3.Call localVarCall = getDistanceToCoastByAddressValidateBeforeCall(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, null);
        Type localVarReturnType = new TypeToken<WaterBodyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Distance To Flood Hazard By Address (asynchronously)
     * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
     * @param address The address of the location (optional)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType This specifies the value of waterBodyType (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDistanceToCoastByAddressAsync(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ApiCallback<WaterBodyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDistanceToCoastByAddressValidateBeforeCall(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, _callback);
        Type localVarReturnType = new TypeToken<WaterBodyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getDistanceToCoastByAddressBatch
     * @param distanceToFloodHazardAddressRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDistanceToCoastByAddressBatchCall(DistanceToFloodHazardAddressRequest distanceToFloodHazardAddressRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = distanceToFloodHazardAddressRequest;

        // create path and map variables
        String localVarPath = "/risks/v1/shoreline/distancetofloodhazard/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDistanceToCoastByAddressBatchValidateBeforeCall(DistanceToFloodHazardAddressRequest distanceToFloodHazardAddressRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'distanceToFloodHazardAddressRequest' is set
        if (distanceToFloodHazardAddressRequest == null) {
            throw new ApiException("Missing the required parameter 'distanceToFloodHazardAddressRequest' when calling getDistanceToCoastByAddressBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getDistanceToCoastByAddressBatchCall(distanceToFloodHazardAddressRequest, _callback);
        return localVarCall;

    }

    /**
     * Post Distance To Flood Hazard By Address
     * This is a Batch offering for &#39;Distance To Flood Hazard By Address&#39; service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
     * @param distanceToFloodHazardAddressRequest  (required)
     * @return DistanceToFloodHazardResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public DistanceToFloodHazardResponse getDistanceToCoastByAddressBatch(DistanceToFloodHazardAddressRequest distanceToFloodHazardAddressRequest) throws ApiException {
        ApiResponse<DistanceToFloodHazardResponse> localVarResp = getDistanceToCoastByAddressBatchWithHttpInfo(distanceToFloodHazardAddressRequest);
        return localVarResp.getData();
    }

    /**
     * Post Distance To Flood Hazard By Address
     * This is a Batch offering for &#39;Distance To Flood Hazard By Address&#39; service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
     * @param distanceToFloodHazardAddressRequest  (required)
     * @return ApiResponse&lt;DistanceToFloodHazardResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DistanceToFloodHazardResponse> getDistanceToCoastByAddressBatchWithHttpInfo(DistanceToFloodHazardAddressRequest distanceToFloodHazardAddressRequest) throws ApiException {
        okhttp3.Call localVarCall = getDistanceToCoastByAddressBatchValidateBeforeCall(distanceToFloodHazardAddressRequest, null);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post Distance To Flood Hazard By Address (asynchronously)
     * This is a Batch offering for &#39;Distance To Flood Hazard By Address&#39; service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
     * @param distanceToFloodHazardAddressRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDistanceToCoastByAddressBatchAsync(DistanceToFloodHazardAddressRequest distanceToFloodHazardAddressRequest, final ApiCallback<DistanceToFloodHazardResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDistanceToCoastByAddressBatchValidateBeforeCall(distanceToFloodHazardAddressRequest, _callback);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getDistanceToCoastByLocation
     * @param longitude The longitude of the location (optional)
     * @param latitude The latitude of the location (optional)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType This specifies the value of waterBodyType (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDistanceToCoastByLocationCall(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/shoreline/distancetofloodhazard/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (maxCandidates != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxCandidates", maxCandidates));
        }

        if (waterBodyType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("waterBodyType", waterBodyType));
        }

        if (searchDistance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("searchDistance", searchDistance));
        }

        if (searchDistanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("searchDistanceUnit", searchDistanceUnit));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDistanceToCoastByLocationValidateBeforeCall(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getDistanceToCoastByLocationCall(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, _callback);
        return localVarCall;

    }

    /**
     * Get Distance To Flood Hazard By Location
     * Accepts latitude &amp; longitude as input and Returns the distance from nearest water bodies along with body name and location.
     * @param longitude The longitude of the location (optional)
     * @param latitude The latitude of the location (optional)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType This specifies the value of waterBodyType (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return WaterBodyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public WaterBodyResponse getDistanceToCoastByLocation(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        ApiResponse<WaterBodyResponse> localVarResp = getDistanceToCoastByLocationWithHttpInfo(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit);
        return localVarResp.getData();
    }

    /**
     * Get Distance To Flood Hazard By Location
     * Accepts latitude &amp; longitude as input and Returns the distance from nearest water bodies along with body name and location.
     * @param longitude The longitude of the location (optional)
     * @param latitude The latitude of the location (optional)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType This specifies the value of waterBodyType (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return ApiResponse&lt;WaterBodyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WaterBodyResponse> getDistanceToCoastByLocationWithHttpInfo(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        okhttp3.Call localVarCall = getDistanceToCoastByLocationValidateBeforeCall(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, null);
        Type localVarReturnType = new TypeToken<WaterBodyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Distance To Flood Hazard By Location (asynchronously)
     * Accepts latitude &amp; longitude as input and Returns the distance from nearest water bodies along with body name and location.
     * @param longitude The longitude of the location (optional)
     * @param latitude The latitude of the location (optional)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType This specifies the value of waterBodyType (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDistanceToCoastByLocationAsync(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ApiCallback<WaterBodyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDistanceToCoastByLocationValidateBeforeCall(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, _callback);
        Type localVarReturnType = new TypeToken<WaterBodyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getDistanceToCoastByLocationBatch
     * @param distanceToFloodHazardLocationRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDistanceToCoastByLocationBatchCall(DistanceToFloodHazardLocationRequest distanceToFloodHazardLocationRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = distanceToFloodHazardLocationRequest;

        // create path and map variables
        String localVarPath = "/risks/v1/shoreline/distancetofloodhazard/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDistanceToCoastByLocationBatchValidateBeforeCall(DistanceToFloodHazardLocationRequest distanceToFloodHazardLocationRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'distanceToFloodHazardLocationRequest' is set
        if (distanceToFloodHazardLocationRequest == null) {
            throw new ApiException("Missing the required parameter 'distanceToFloodHazardLocationRequest' when calling getDistanceToCoastByLocationBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getDistanceToCoastByLocationBatchCall(distanceToFloodHazardLocationRequest, _callback);
        return localVarCall;

    }

    /**
     * Post Distance To Flood Hazard By Location
     * This is a Batch offering for &#39;Distance To Flood Hazard By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
     * @param distanceToFloodHazardLocationRequest  (required)
     * @return DistanceToFloodHazardResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public DistanceToFloodHazardResponse getDistanceToCoastByLocationBatch(DistanceToFloodHazardLocationRequest distanceToFloodHazardLocationRequest) throws ApiException {
        ApiResponse<DistanceToFloodHazardResponse> localVarResp = getDistanceToCoastByLocationBatchWithHttpInfo(distanceToFloodHazardLocationRequest);
        return localVarResp.getData();
    }

    /**
     * Post Distance To Flood Hazard By Location
     * This is a Batch offering for &#39;Distance To Flood Hazard By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
     * @param distanceToFloodHazardLocationRequest  (required)
     * @return ApiResponse&lt;DistanceToFloodHazardResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DistanceToFloodHazardResponse> getDistanceToCoastByLocationBatchWithHttpInfo(DistanceToFloodHazardLocationRequest distanceToFloodHazardLocationRequest) throws ApiException {
        okhttp3.Call localVarCall = getDistanceToCoastByLocationBatchValidateBeforeCall(distanceToFloodHazardLocationRequest, null);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post Distance To Flood Hazard By Location (asynchronously)
     * This is a Batch offering for &#39;Distance To Flood Hazard By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
     * @param distanceToFloodHazardLocationRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDistanceToCoastByLocationBatchAsync(DistanceToFloodHazardLocationRequest distanceToFloodHazardLocationRequest, final ApiCallback<DistanceToFloodHazardResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDistanceToCoastByLocationBatchValidateBeforeCall(distanceToFloodHazardLocationRequest, _callback);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEarthquakeHistory
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param minMagnitude Minimum richter scale magnitude (optional)
     * @param maxMagnitude Maximum Richter scale magnitude (optional)
     * @param maxCandidates Maximum response events (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEarthquakeHistoryCall(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/earthquakehistory";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (postCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("postCode", postCode));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endDate", endDate));
        }

        if (minMagnitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minMagnitude", minMagnitude));
        }

        if (maxMagnitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxMagnitude", maxMagnitude));
        }

        if (maxCandidates != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxCandidates", maxCandidates));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEarthquakeHistoryValidateBeforeCall(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'postCode' is set
        if (postCode == null) {
            throw new ApiException("Missing the required parameter 'postCode' when calling getEarthquakeHistory(Async)");
        }
        

        okhttp3.Call localVarCall = getEarthquakeHistoryCall(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates, _callback);
        return localVarCall;

    }

    /**
     * Earthquake History
     * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param minMagnitude Minimum richter scale magnitude (optional)
     * @param maxMagnitude Maximum Richter scale magnitude (optional)
     * @param maxCandidates Maximum response events (optional)
     * @return EarthquakeHistory
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public EarthquakeHistory getEarthquakeHistory(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates) throws ApiException {
        ApiResponse<EarthquakeHistory> localVarResp = getEarthquakeHistoryWithHttpInfo(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates);
        return localVarResp.getData();
    }

    /**
     * Earthquake History
     * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param minMagnitude Minimum richter scale magnitude (optional)
     * @param maxMagnitude Maximum Richter scale magnitude (optional)
     * @param maxCandidates Maximum response events (optional)
     * @return ApiResponse&lt;EarthquakeHistory&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EarthquakeHistory> getEarthquakeHistoryWithHttpInfo(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates) throws ApiException {
        okhttp3.Call localVarCall = getEarthquakeHistoryValidateBeforeCall(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates, null);
        Type localVarReturnType = new TypeToken<EarthquakeHistory>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Earthquake History (asynchronously)
     * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param minMagnitude Minimum richter scale magnitude (optional)
     * @param maxMagnitude Maximum Richter scale magnitude (optional)
     * @param maxCandidates Maximum response events (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEarthquakeHistoryAsync(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates, final ApiCallback<EarthquakeHistory> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEarthquakeHistoryValidateBeforeCall(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates, _callback);
        Type localVarReturnType = new TypeToken<EarthquakeHistory>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEarthquakeRiskByAddress
     * @param address free form address text (required)
     * @param richterValue all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEarthquakeRiskByAddressCall(String address, String richterValue, String includeGeometry, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/earthquake/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (richterValue != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("richterValue", richterValue));
        }

        if (includeGeometry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeGeometry", includeGeometry));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEarthquakeRiskByAddressValidateBeforeCall(String address, String richterValue, String includeGeometry, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getEarthquakeRiskByAddress(Async)");
        }
        

        okhttp3.Call localVarCall = getEarthquakeRiskByAddressCall(address, richterValue, includeGeometry, _callback);
        return localVarCall;

    }

    /**
     * Get Earthquake Risk By Address
     * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
     * @param address free form address text (required)
     * @param richterValue all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return EarthquakeRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public EarthquakeRiskResponse getEarthquakeRiskByAddress(String address, String richterValue, String includeGeometry) throws ApiException {
        ApiResponse<EarthquakeRiskResponse> localVarResp = getEarthquakeRiskByAddressWithHttpInfo(address, richterValue, includeGeometry);
        return localVarResp.getData();
    }

    /**
     * Get Earthquake Risk By Address
     * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
     * @param address free form address text (required)
     * @param richterValue all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;EarthquakeRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EarthquakeRiskResponse> getEarthquakeRiskByAddressWithHttpInfo(String address, String richterValue, String includeGeometry) throws ApiException {
        okhttp3.Call localVarCall = getEarthquakeRiskByAddressValidateBeforeCall(address, richterValue, includeGeometry, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Earthquake Risk By Address (asynchronously)
     * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
     * @param address free form address text (required)
     * @param richterValue all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEarthquakeRiskByAddressAsync(String address, String richterValue, String includeGeometry, final ApiCallback<EarthquakeRiskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEarthquakeRiskByAddressValidateBeforeCall(address, richterValue, includeGeometry, _callback);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEarthquakeRiskByAddressBatch
     * @param earthquakeRiskByAddressRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEarthquakeRiskByAddressBatchCall(EarthquakeRiskByAddressRequest earthquakeRiskByAddressRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = earthquakeRiskByAddressRequest;

        // create path and map variables
        String localVarPath = "/risks/v1/earthquake/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEarthquakeRiskByAddressBatchValidateBeforeCall(EarthquakeRiskByAddressRequest earthquakeRiskByAddressRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'earthquakeRiskByAddressRequest' is set
        if (earthquakeRiskByAddressRequest == null) {
            throw new ApiException("Missing the required parameter 'earthquakeRiskByAddressRequest' when calling getEarthquakeRiskByAddressBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getEarthquakeRiskByAddressBatchCall(earthquakeRiskByAddressRequest, _callback);
        return localVarCall;

    }

    /**
     * Post Earthquake Risk By Address
     * This is a Batch offering for &#39;Earthquake Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
     * @param earthquakeRiskByAddressRequest  (required)
     * @return EarthquakeRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public EarthquakeRiskResponseList getEarthquakeRiskByAddressBatch(EarthquakeRiskByAddressRequest earthquakeRiskByAddressRequest) throws ApiException {
        ApiResponse<EarthquakeRiskResponseList> localVarResp = getEarthquakeRiskByAddressBatchWithHttpInfo(earthquakeRiskByAddressRequest);
        return localVarResp.getData();
    }

    /**
     * Post Earthquake Risk By Address
     * This is a Batch offering for &#39;Earthquake Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
     * @param earthquakeRiskByAddressRequest  (required)
     * @return ApiResponse&lt;EarthquakeRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EarthquakeRiskResponseList> getEarthquakeRiskByAddressBatchWithHttpInfo(EarthquakeRiskByAddressRequest earthquakeRiskByAddressRequest) throws ApiException {
        okhttp3.Call localVarCall = getEarthquakeRiskByAddressBatchValidateBeforeCall(earthquakeRiskByAddressRequest, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponseList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post Earthquake Risk By Address (asynchronously)
     * This is a Batch offering for &#39;Earthquake Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
     * @param earthquakeRiskByAddressRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEarthquakeRiskByAddressBatchAsync(EarthquakeRiskByAddressRequest earthquakeRiskByAddressRequest, final ApiCallback<EarthquakeRiskResponseList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEarthquakeRiskByAddressBatchValidateBeforeCall(earthquakeRiskByAddressRequest, _callback);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponseList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEarthquakeRiskByLocation
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param richterValue all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEarthquakeRiskByLocationCall(String longitude, String latitude, String richterValue, String includeGeometry, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/earthquake/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (richterValue != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("richterValue", richterValue));
        }

        if (includeGeometry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeGeometry", includeGeometry));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEarthquakeRiskByLocationValidateBeforeCall(String longitude, String latitude, String richterValue, String includeGeometry, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getEarthquakeRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getEarthquakeRiskByLocation(Async)");
        }
        

        okhttp3.Call localVarCall = getEarthquakeRiskByLocationCall(longitude, latitude, richterValue, includeGeometry, _callback);
        return localVarCall;

    }

    /**
     * Get Earthquake Risk By Location
     * Accepts latitude &amp; longitude as input and Returns counts of earthquakes for various richter measurements and values.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param richterValue all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return EarthquakeRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public EarthquakeRiskResponse getEarthquakeRiskByLocation(String longitude, String latitude, String richterValue, String includeGeometry) throws ApiException {
        ApiResponse<EarthquakeRiskResponse> localVarResp = getEarthquakeRiskByLocationWithHttpInfo(longitude, latitude, richterValue, includeGeometry);
        return localVarResp.getData();
    }

    /**
     * Get Earthquake Risk By Location
     * Accepts latitude &amp; longitude as input and Returns counts of earthquakes for various richter measurements and values.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param richterValue all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;EarthquakeRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EarthquakeRiskResponse> getEarthquakeRiskByLocationWithHttpInfo(String longitude, String latitude, String richterValue, String includeGeometry) throws ApiException {
        okhttp3.Call localVarCall = getEarthquakeRiskByLocationValidateBeforeCall(longitude, latitude, richterValue, includeGeometry, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Earthquake Risk By Location (asynchronously)
     * Accepts latitude &amp; longitude as input and Returns counts of earthquakes for various richter measurements and values.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param richterValue all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEarthquakeRiskByLocationAsync(String longitude, String latitude, String richterValue, String includeGeometry, final ApiCallback<EarthquakeRiskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEarthquakeRiskByLocationValidateBeforeCall(longitude, latitude, richterValue, includeGeometry, _callback);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEarthquakeRiskByLocationBatch
     * @param earthquakeRiskByLocationRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEarthquakeRiskByLocationBatchCall(EarthquakeRiskByLocationRequest earthquakeRiskByLocationRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = earthquakeRiskByLocationRequest;

        // create path and map variables
        String localVarPath = "/risks/v1/earthquake/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEarthquakeRiskByLocationBatchValidateBeforeCall(EarthquakeRiskByLocationRequest earthquakeRiskByLocationRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'earthquakeRiskByLocationRequest' is set
        if (earthquakeRiskByLocationRequest == null) {
            throw new ApiException("Missing the required parameter 'earthquakeRiskByLocationRequest' when calling getEarthquakeRiskByLocationBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getEarthquakeRiskByLocationBatchCall(earthquakeRiskByLocationRequest, _callback);
        return localVarCall;

    }

    /**
     * Post Earthquake Risk By Location
     * This is a Batch offering for &#39;Earthquake Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
     * @param earthquakeRiskByLocationRequest  (required)
     * @return EarthquakeRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public EarthquakeRiskResponseList getEarthquakeRiskByLocationBatch(EarthquakeRiskByLocationRequest earthquakeRiskByLocationRequest) throws ApiException {
        ApiResponse<EarthquakeRiskResponseList> localVarResp = getEarthquakeRiskByLocationBatchWithHttpInfo(earthquakeRiskByLocationRequest);
        return localVarResp.getData();
    }

    /**
     * Post Earthquake Risk By Location
     * This is a Batch offering for &#39;Earthquake Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
     * @param earthquakeRiskByLocationRequest  (required)
     * @return ApiResponse&lt;EarthquakeRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EarthquakeRiskResponseList> getEarthquakeRiskByLocationBatchWithHttpInfo(EarthquakeRiskByLocationRequest earthquakeRiskByLocationRequest) throws ApiException {
        okhttp3.Call localVarCall = getEarthquakeRiskByLocationBatchValidateBeforeCall(earthquakeRiskByLocationRequest, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponseList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post Earthquake Risk By Location (asynchronously)
     * This is a Batch offering for &#39;Earthquake Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
     * @param earthquakeRiskByLocationRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEarthquakeRiskByLocationBatchAsync(EarthquakeRiskByLocationRequest earthquakeRiskByLocationRequest, final ApiCallback<EarthquakeRiskResponseList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEarthquakeRiskByLocationBatchValidateBeforeCall(earthquakeRiskByLocationRequest, _callback);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponseList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFireHistory
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param maxCandidates Maximum response events (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireHistoryCall(String postCode, String startDate, String endDate, String maxCandidates, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/firehistory";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (postCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("postCode", postCode));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endDate", endDate));
        }

        if (maxCandidates != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxCandidates", maxCandidates));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFireHistoryValidateBeforeCall(String postCode, String startDate, String endDate, String maxCandidates, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'postCode' is set
        if (postCode == null) {
            throw new ApiException("Missing the required parameter 'postCode' when calling getFireHistory(Async)");
        }
        

        okhttp3.Call localVarCall = getFireHistoryCall(postCode, startDate, endDate, maxCandidates, _callback);
        return localVarCall;

    }

    /**
     * Get Fire History
     * Accepts postcode as input and Returns fire event details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param maxCandidates Maximum response events (optional)
     * @return FireHistory
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FireHistory getFireHistory(String postCode, String startDate, String endDate, String maxCandidates) throws ApiException {
        ApiResponse<FireHistory> localVarResp = getFireHistoryWithHttpInfo(postCode, startDate, endDate, maxCandidates);
        return localVarResp.getData();
    }

    /**
     * Get Fire History
     * Accepts postcode as input and Returns fire event details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param maxCandidates Maximum response events (optional)
     * @return ApiResponse&lt;FireHistory&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FireHistory> getFireHistoryWithHttpInfo(String postCode, String startDate, String endDate, String maxCandidates) throws ApiException {
        okhttp3.Call localVarCall = getFireHistoryValidateBeforeCall(postCode, startDate, endDate, maxCandidates, null);
        Type localVarReturnType = new TypeToken<FireHistory>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Fire History (asynchronously)
     * Accepts postcode as input and Returns fire event details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param maxCandidates Maximum response events (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireHistoryAsync(String postCode, String startDate, String endDate, String maxCandidates, final ApiCallback<FireHistory> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFireHistoryValidateBeforeCall(postCode, startDate, endDate, maxCandidates, _callback);
        Type localVarReturnType = new TypeToken<FireHistory>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFireRiskByAddress
     * @param address Free form address text (required)
     * @param includeGeometry Flag to return Geometry default is N (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireRiskByAddressCall(String address, String includeGeometry, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/fire/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (includeGeometry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeGeometry", includeGeometry));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFireRiskByAddressValidateBeforeCall(String address, String includeGeometry, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getFireRiskByAddress(Async)");
        }
        

        okhttp3.Call localVarCall = getFireRiskByAddressCall(address, includeGeometry, _callback);
        return localVarCall;

    }

    /**
     * Get Fire Risk By Address
     * Accepts addresses as input and Returns fire risk data by risk types.
     * @param address Free form address text (required)
     * @param includeGeometry Flag to return Geometry default is N (optional)
     * @return FireRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FireRiskResponse getFireRiskByAddress(String address, String includeGeometry) throws ApiException {
        ApiResponse<FireRiskResponse> localVarResp = getFireRiskByAddressWithHttpInfo(address, includeGeometry);
        return localVarResp.getData();
    }

    /**
     * Get Fire Risk By Address
     * Accepts addresses as input and Returns fire risk data by risk types.
     * @param address Free form address text (required)
     * @param includeGeometry Flag to return Geometry default is N (optional)
     * @return ApiResponse&lt;FireRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FireRiskResponse> getFireRiskByAddressWithHttpInfo(String address, String includeGeometry) throws ApiException {
        okhttp3.Call localVarCall = getFireRiskByAddressValidateBeforeCall(address, includeGeometry, null);
        Type localVarReturnType = new TypeToken<FireRiskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Fire Risk By Address (asynchronously)
     * Accepts addresses as input and Returns fire risk data by risk types.
     * @param address Free form address text (required)
     * @param includeGeometry Flag to return Geometry default is N (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireRiskByAddressAsync(String address, String includeGeometry, final ApiCallback<FireRiskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFireRiskByAddressValidateBeforeCall(address, includeGeometry, _callback);
        Type localVarReturnType = new TypeToken<FireRiskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFireRiskByAddressBatch
     * @param fireRiskByAddressRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireRiskByAddressBatchCall(FireRiskByAddressRequest fireRiskByAddressRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fireRiskByAddressRequest;

        // create path and map variables
        String localVarPath = "/risks/v1/fire/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFireRiskByAddressBatchValidateBeforeCall(FireRiskByAddressRequest fireRiskByAddressRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'fireRiskByAddressRequest' is set
        if (fireRiskByAddressRequest == null) {
            throw new ApiException("Missing the required parameter 'fireRiskByAddressRequest' when calling getFireRiskByAddressBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getFireRiskByAddressBatchCall(fireRiskByAddressRequest, _callback);
        return localVarCall;

    }

    /**
     * Post Fire Risk By Address
     * This is a Batch offering for &#39;Fire Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
     * @param fireRiskByAddressRequest  (required)
     * @return FireRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FireRiskResponseList getFireRiskByAddressBatch(FireRiskByAddressRequest fireRiskByAddressRequest) throws ApiException {
        ApiResponse<FireRiskResponseList> localVarResp = getFireRiskByAddressBatchWithHttpInfo(fireRiskByAddressRequest);
        return localVarResp.getData();
    }

    /**
     * Post Fire Risk By Address
     * This is a Batch offering for &#39;Fire Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
     * @param fireRiskByAddressRequest  (required)
     * @return ApiResponse&lt;FireRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FireRiskResponseList> getFireRiskByAddressBatchWithHttpInfo(FireRiskByAddressRequest fireRiskByAddressRequest) throws ApiException {
        okhttp3.Call localVarCall = getFireRiskByAddressBatchValidateBeforeCall(fireRiskByAddressRequest, null);
        Type localVarReturnType = new TypeToken<FireRiskResponseList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post Fire Risk By Address (asynchronously)
     * This is a Batch offering for &#39;Fire Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
     * @param fireRiskByAddressRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireRiskByAddressBatchAsync(FireRiskByAddressRequest fireRiskByAddressRequest, final ApiCallback<FireRiskResponseList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFireRiskByAddressBatchValidateBeforeCall(fireRiskByAddressRequest, _callback);
        Type localVarReturnType = new TypeToken<FireRiskResponseList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFireRiskByLocation
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeGeometry Flag to return Geometry default is N (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireRiskByLocationCall(String longitude, String latitude, String includeGeometry, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/fire/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (includeGeometry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeGeometry", includeGeometry));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFireRiskByLocationValidateBeforeCall(String longitude, String latitude, String includeGeometry, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getFireRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getFireRiskByLocation(Async)");
        }
        

        okhttp3.Call localVarCall = getFireRiskByLocationCall(longitude, latitude, includeGeometry, _callback);
        return localVarCall;

    }

    /**
     * Get Fire Risk By Location
     * Accepts latitude &amp; longitude as input and Returns fire risk data by risk types.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeGeometry Flag to return Geometry default is N (optional)
     * @return FireRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FireRiskResponse getFireRiskByLocation(String longitude, String latitude, String includeGeometry) throws ApiException {
        ApiResponse<FireRiskResponse> localVarResp = getFireRiskByLocationWithHttpInfo(longitude, latitude, includeGeometry);
        return localVarResp.getData();
    }

    /**
     * Get Fire Risk By Location
     * Accepts latitude &amp; longitude as input and Returns fire risk data by risk types.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeGeometry Flag to return Geometry default is N (optional)
     * @return ApiResponse&lt;FireRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FireRiskResponse> getFireRiskByLocationWithHttpInfo(String longitude, String latitude, String includeGeometry) throws ApiException {
        okhttp3.Call localVarCall = getFireRiskByLocationValidateBeforeCall(longitude, latitude, includeGeometry, null);
        Type localVarReturnType = new TypeToken<FireRiskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Fire Risk By Location (asynchronously)
     * Accepts latitude &amp; longitude as input and Returns fire risk data by risk types.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeGeometry Flag to return Geometry default is N (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireRiskByLocationAsync(String longitude, String latitude, String includeGeometry, final ApiCallback<FireRiskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFireRiskByLocationValidateBeforeCall(longitude, latitude, includeGeometry, _callback);
        Type localVarReturnType = new TypeToken<FireRiskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFireRiskByLocationBatch
     * @param fireRiskByLocationRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireRiskByLocationBatchCall(FireRiskByLocationRequest fireRiskByLocationRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fireRiskByLocationRequest;

        // create path and map variables
        String localVarPath = "/risks/v1/fire/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFireRiskByLocationBatchValidateBeforeCall(FireRiskByLocationRequest fireRiskByLocationRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'fireRiskByLocationRequest' is set
        if (fireRiskByLocationRequest == null) {
            throw new ApiException("Missing the required parameter 'fireRiskByLocationRequest' when calling getFireRiskByLocationBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getFireRiskByLocationBatchCall(fireRiskByLocationRequest, _callback);
        return localVarCall;

    }

    /**
     * Post Fire Risk By Location
     * This is a Batch offering for &#39;Fire Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
     * @param fireRiskByLocationRequest  (required)
     * @return FireRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FireRiskResponseList getFireRiskByLocationBatch(FireRiskByLocationRequest fireRiskByLocationRequest) throws ApiException {
        ApiResponse<FireRiskResponseList> localVarResp = getFireRiskByLocationBatchWithHttpInfo(fireRiskByLocationRequest);
        return localVarResp.getData();
    }

    /**
     * Post Fire Risk By Location
     * This is a Batch offering for &#39;Fire Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
     * @param fireRiskByLocationRequest  (required)
     * @return ApiResponse&lt;FireRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FireRiskResponseList> getFireRiskByLocationBatchWithHttpInfo(FireRiskByLocationRequest fireRiskByLocationRequest) throws ApiException {
        okhttp3.Call localVarCall = getFireRiskByLocationBatchValidateBeforeCall(fireRiskByLocationRequest, null);
        Type localVarReturnType = new TypeToken<FireRiskResponseList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post Fire Risk By Location (asynchronously)
     * This is a Batch offering for &#39;Fire Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
     * @param fireRiskByLocationRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireRiskByLocationBatchAsync(FireRiskByLocationRequest fireRiskByLocationRequest, final ApiCallback<FireRiskResponseList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFireRiskByLocationBatchValidateBeforeCall(fireRiskByLocationRequest, _callback);
        Type localVarReturnType = new TypeToken<FireRiskResponseList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFireStationByAddress
     * @param address Free Address (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit minutes (default), hours, seconds, milliseconds (optional)
     * @param travelDistance Max travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Feet (default), Kilometers, Miles, Meters (optional)
     * @param sortBy time (default), distance (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireStationByAddressCall(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/firestation/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (maxCandidates != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxCandidates", maxCandidates));
        }

        if (travelTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("travelTime", travelTime));
        }

        if (travelTimeUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("travelTimeUnit", travelTimeUnit));
        }

        if (travelDistance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("travelDistance", travelDistance));
        }

        if (travelDistanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("travelDistanceUnit", travelDistanceUnit));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortBy", sortBy));
        }

        if (historicTrafficTimeBucket != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("historicTrafficTimeBucket", historicTrafficTimeBucket));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFireStationByAddressValidateBeforeCall(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getFireStationByAddress(Async)");
        }
        

        okhttp3.Call localVarCall = getFireStationByAddressCall(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, _callback);
        return localVarCall;

    }

    /**
     * Get Fire Station By Address
     * Accepts addresses as input and Returns nearest fire stations.
     * @param address Free Address (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit minutes (default), hours, seconds, milliseconds (optional)
     * @param travelDistance Max travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Feet (default), Kilometers, Miles, Meters (optional)
     * @param sortBy time (default), distance (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return FireStations
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FireStations getFireStationByAddress(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        ApiResponse<FireStations> localVarResp = getFireStationByAddressWithHttpInfo(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket);
        return localVarResp.getData();
    }

    /**
     * Get Fire Station By Address
     * Accepts addresses as input and Returns nearest fire stations.
     * @param address Free Address (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit minutes (default), hours, seconds, milliseconds (optional)
     * @param travelDistance Max travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Feet (default), Kilometers, Miles, Meters (optional)
     * @param sortBy time (default), distance (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return ApiResponse&lt;FireStations&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FireStations> getFireStationByAddressWithHttpInfo(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        okhttp3.Call localVarCall = getFireStationByAddressValidateBeforeCall(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, null);
        Type localVarReturnType = new TypeToken<FireStations>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Fire Station By Address (asynchronously)
     * Accepts addresses as input and Returns nearest fire stations.
     * @param address Free Address (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit minutes (default), hours, seconds, milliseconds (optional)
     * @param travelDistance Max travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Feet (default), Kilometers, Miles, Meters (optional)
     * @param sortBy time (default), distance (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireStationByAddressAsync(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ApiCallback<FireStations> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFireStationByAddressValidateBeforeCall(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, _callback);
        Type localVarReturnType = new TypeToken<FireStations>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFireStationByLocation
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit minutes (default), hours, seconds, milliseconds (optional)
     * @param travelDistance Max travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Feet (default), Kilometers, Miles, Meters (optional)
     * @param sortBy time (default), distance (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireStationByLocationCall(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/firestation/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (maxCandidates != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxCandidates", maxCandidates));
        }

        if (travelTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("travelTime", travelTime));
        }

        if (travelTimeUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("travelTimeUnit", travelTimeUnit));
        }

        if (travelDistance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("travelDistance", travelDistance));
        }

        if (travelDistanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("travelDistanceUnit", travelDistanceUnit));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortBy", sortBy));
        }

        if (historicTrafficTimeBucket != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("historicTrafficTimeBucket", historicTrafficTimeBucket));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFireStationByLocationValidateBeforeCall(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getFireStationByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getFireStationByLocation(Async)");
        }
        

        okhttp3.Call localVarCall = getFireStationByLocationCall(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, _callback);
        return localVarCall;

    }

    /**
     * Get Fire Station By Location
     * Accepts latitude &amp; longitude as input and Returns nearest fire stations.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit minutes (default), hours, seconds, milliseconds (optional)
     * @param travelDistance Max travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Feet (default), Kilometers, Miles, Meters (optional)
     * @param sortBy time (default), distance (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return FireStations
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FireStations getFireStationByLocation(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        ApiResponse<FireStations> localVarResp = getFireStationByLocationWithHttpInfo(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket);
        return localVarResp.getData();
    }

    /**
     * Get Fire Station By Location
     * Accepts latitude &amp; longitude as input and Returns nearest fire stations.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit minutes (default), hours, seconds, milliseconds (optional)
     * @param travelDistance Max travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Feet (default), Kilometers, Miles, Meters (optional)
     * @param sortBy time (default), distance (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return ApiResponse&lt;FireStations&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FireStations> getFireStationByLocationWithHttpInfo(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        okhttp3.Call localVarCall = getFireStationByLocationValidateBeforeCall(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, null);
        Type localVarReturnType = new TypeToken<FireStations>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Fire Station By Location (asynchronously)
     * Accepts latitude &amp; longitude as input and Returns nearest fire stations.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit minutes (default), hours, seconds, milliseconds (optional)
     * @param travelDistance Max travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Feet (default), Kilometers, Miles, Meters (optional)
     * @param sortBy time (default), distance (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFireStationByLocationAsync(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ApiCallback<FireStations> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFireStationByLocationValidateBeforeCall(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, _callback);
        Type localVarReturnType = new TypeToken<FireStations>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFloodRiskByAddress
     * @param address Free text Address (required)
     * @param includeZoneDesc Flag to return zone description (optional)
     * @param includeGeometry Flag to return Geometry (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFloodRiskByAddressCall(String address, String includeZoneDesc, String includeGeometry, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/flood/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (includeZoneDesc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeZoneDesc", includeZoneDesc));
        }

        if (includeGeometry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeGeometry", includeGeometry));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFloodRiskByAddressValidateBeforeCall(String address, String includeZoneDesc, String includeGeometry, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getFloodRiskByAddress(Async)");
        }
        

        okhttp3.Call localVarCall = getFloodRiskByAddressCall(address, includeZoneDesc, includeGeometry, _callback);
        return localVarCall;

    }

    /**
     * Get Flood Risk By Address
     * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param address Free text Address (required)
     * @param includeZoneDesc Flag to return zone description (optional)
     * @param includeGeometry Flag to return Geometry (optional)
     * @return FloodRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FloodRiskResponse getFloodRiskByAddress(String address, String includeZoneDesc, String includeGeometry) throws ApiException {
        ApiResponse<FloodRiskResponse> localVarResp = getFloodRiskByAddressWithHttpInfo(address, includeZoneDesc, includeGeometry);
        return localVarResp.getData();
    }

    /**
     * Get Flood Risk By Address
     * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param address Free text Address (required)
     * @param includeZoneDesc Flag to return zone description (optional)
     * @param includeGeometry Flag to return Geometry (optional)
     * @return ApiResponse&lt;FloodRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FloodRiskResponse> getFloodRiskByAddressWithHttpInfo(String address, String includeZoneDesc, String includeGeometry) throws ApiException {
        okhttp3.Call localVarCall = getFloodRiskByAddressValidateBeforeCall(address, includeZoneDesc, includeGeometry, null);
        Type localVarReturnType = new TypeToken<FloodRiskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Flood Risk By Address (asynchronously)
     * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param address Free text Address (required)
     * @param includeZoneDesc Flag to return zone description (optional)
     * @param includeGeometry Flag to return Geometry (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFloodRiskByAddressAsync(String address, String includeZoneDesc, String includeGeometry, final ApiCallback<FloodRiskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFloodRiskByAddressValidateBeforeCall(address, includeZoneDesc, includeGeometry, _callback);
        Type localVarReturnType = new TypeToken<FloodRiskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFloodRiskByAddressBatch
     * @param floodRiskByAddressRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFloodRiskByAddressBatchCall(FloodRiskByAddressRequest floodRiskByAddressRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = floodRiskByAddressRequest;

        // create path and map variables
        String localVarPath = "/risks/v1/flood/byaddress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFloodRiskByAddressBatchValidateBeforeCall(FloodRiskByAddressRequest floodRiskByAddressRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'floodRiskByAddressRequest' is set
        if (floodRiskByAddressRequest == null) {
            throw new ApiException("Missing the required parameter 'floodRiskByAddressRequest' when calling getFloodRiskByAddressBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getFloodRiskByAddressBatchCall(floodRiskByAddressRequest, _callback);
        return localVarCall;

    }

    /**
     * Post Flood Risk By Address
     * This is a Batch offering for &#39;Flood Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
     * @param floodRiskByAddressRequest  (required)
     * @return FloodRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FloodRiskResponseList getFloodRiskByAddressBatch(FloodRiskByAddressRequest floodRiskByAddressRequest) throws ApiException {
        ApiResponse<FloodRiskResponseList> localVarResp = getFloodRiskByAddressBatchWithHttpInfo(floodRiskByAddressRequest);
        return localVarResp.getData();
    }

    /**
     * Post Flood Risk By Address
     * This is a Batch offering for &#39;Flood Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
     * @param floodRiskByAddressRequest  (required)
     * @return ApiResponse&lt;FloodRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FloodRiskResponseList> getFloodRiskByAddressBatchWithHttpInfo(FloodRiskByAddressRequest floodRiskByAddressRequest) throws ApiException {
        okhttp3.Call localVarCall = getFloodRiskByAddressBatchValidateBeforeCall(floodRiskByAddressRequest, null);
        Type localVarReturnType = new TypeToken<FloodRiskResponseList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post Flood Risk By Address (asynchronously)
     * This is a Batch offering for &#39;Flood Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
     * @param floodRiskByAddressRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFloodRiskByAddressBatchAsync(FloodRiskByAddressRequest floodRiskByAddressRequest, final ApiCallback<FloodRiskResponseList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFloodRiskByAddressBatchValidateBeforeCall(floodRiskByAddressRequest, _callback);
        Type localVarReturnType = new TypeToken<FloodRiskResponseList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFloodRiskByLocation
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeZoneDesc Flag to return zone description (optional)
     * @param includeGeometry Flag to return Geometry (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFloodRiskByLocationCall(String longitude, String latitude, String includeZoneDesc, String includeGeometry, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/risks/v1/flood/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (includeZoneDesc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeZoneDesc", includeZoneDesc));
        }

        if (includeGeometry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeGeometry", includeGeometry));
        }

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFloodRiskByLocationValidateBeforeCall(String longitude, String latitude, String includeZoneDesc, String includeGeometry, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getFloodRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getFloodRiskByLocation(Async)");
        }
        

        okhttp3.Call localVarCall = getFloodRiskByLocationCall(longitude, latitude, includeZoneDesc, includeGeometry, _callback);
        return localVarCall;

    }

    /**
     * Get Flood Risk By Location
     * Accepts latitude &amp; longitude as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeZoneDesc Flag to return zone description (optional)
     * @param includeGeometry Flag to return Geometry (optional)
     * @return FloodRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FloodRiskResponse getFloodRiskByLocation(String longitude, String latitude, String includeZoneDesc, String includeGeometry) throws ApiException {
        ApiResponse<FloodRiskResponse> localVarResp = getFloodRiskByLocationWithHttpInfo(longitude, latitude, includeZoneDesc, includeGeometry);
        return localVarResp.getData();
    }

    /**
     * Get Flood Risk By Location
     * Accepts latitude &amp; longitude as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeZoneDesc Flag to return zone description (optional)
     * @param includeGeometry Flag to return Geometry (optional)
     * @return ApiResponse&lt;FloodRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FloodRiskResponse> getFloodRiskByLocationWithHttpInfo(String longitude, String latitude, String includeZoneDesc, String includeGeometry) throws ApiException {
        okhttp3.Call localVarCall = getFloodRiskByLocationValidateBeforeCall(longitude, latitude, includeZoneDesc, includeGeometry, null);
        Type localVarReturnType = new TypeToken<FloodRiskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Flood Risk By Location (asynchronously)
     * Accepts latitude &amp; longitude as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeZoneDesc Flag to return zone description (optional)
     * @param includeGeometry Flag to return Geometry (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFloodRiskByLocationAsync(String longitude, String latitude, String includeZoneDesc, String includeGeometry, final ApiCallback<FloodRiskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFloodRiskByLocationValidateBeforeCall(longitude, latitude, includeZoneDesc, includeGeometry, _callback);
        Type localVarReturnType = new TypeToken<FloodRiskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFloodRiskByLocationBatch
     * @param floodRiskByLocationRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFloodRiskByLocationBatchCall(FloodRiskByLocationRequest floodRiskByLocationRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = floodRiskByLocationRequest;

        // create path and map variables
        String localVarPath = "/risks/v1/flood/bylocation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarHeaderParams != null && localVarContentTypes != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFloodRiskByLocationBatchValidateBeforeCall(FloodRiskByLocationRequest floodRiskByLocationRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'floodRiskByLocationRequest' is set
        if (floodRiskByLocationRequest == null) {
            throw new ApiException("Missing the required parameter 'floodRiskByLocationRequest' when calling getFloodRiskByLocationBatch(Async)");
        }
        

        okhttp3.Call localVarCall = getFloodRiskByLocationBatchCall(floodRiskByLocationRequest, _callback);
        return localVarCall;

    }

    /**
     * Post Flood Risk By Location
     * This is a Batch offering for &#39;Flood Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
     * @param floodRiskByLocationRequest  (required)
     * @return FloodRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FloodRiskResponseList getFloodRiskByLocationBatch(FloodRiskByLocationRequest floodRiskByLocationRequest) throws ApiException {
        ApiResponse<FloodRiskResponseList> localVarResp = getFloodRiskByLocationBatchWithHttpInfo(floodRiskByLocationRequest);
        return localVarResp.getData();
    }

    /**
     * Post Flood Risk By Location
     * This is a Batch offering for &#39;Flood Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
     * @param floodRiskByLocationRequest  (required)
     * @return ApiResponse&lt;FloodRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FloodRiskResponseList> getFloodRiskByLocationBatchWithHttpInfo(FloodRiskByLocationRequest floodRiskByLocationRequest) throws ApiException {
        okhttp3.Call localVarCall = getFloodRiskByLocationBatchValidateBeforeCall(floodRiskByLocationRequest, null);
        Type localVarReturnType = new TypeToken<FloodRiskResponseList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post Flood Risk By Location (asynchronously)
     * This is a Batch offering for &#39;Flood Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
     * @param floodRiskByLocationRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFloodRiskByLocationBatchAsync(FloodRiskByLocationRequest floodRiskByLocationRequest, final ApiCallback<FloodRiskResponseList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFloodRiskByLocationBatchValidateBeforeCall(floodRiskByLocationRequest, _callback);
        Type localVarReturnType = new TypeToken<FloodRiskResponseList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
